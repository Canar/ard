#!/bin/bash
# please?

# i wanna replace useless shit like getmntent
	# hell, mount just wraps a kernel function
# /etc/fstab is defined by a text file
# wiz is code to generate a filesystem and centralize config
# config is code, code is config, documentation is config
# don't repeat yourself
# permit the user to get rid of extraneous bullshit
# ignore case. sentences are commands. paragraphs are blocks.
# every function has a machine code implementation.
# these implementations are composable.

# make debian chroot
	# chroot is a noun, an object
	# debian is an adjective; it refines an object
	# Ruby classes are nouns, Ruby modules are adjectives

# use inotify daemon to build a composable file system

#lazy fucks at ceph
#mimicked their fs before they gave me a product

#list as a data type is implementable NOW in C
#this project could be well on its way tomorrow
#EVENT-DRIVEN! (think "futures", which are threads paused awaiting completion
#programs fulfill contracts
# - line-buffer contract
# - ncurses terminal contract

#datatype object
#all functions take a datatype and emit a datatype

#log is a keyword. datatype is logged along with entrypoint

#code is accessible as its own ast

#event-driven means it fulfills the functions of a unix init

#basic program has input, output, log, event handlers
#basic program can be

#linux object for mounting!
#some scripting objects are line-buffer contract (or similar)
#file contract and line-buffer contract are equivalent

release=stable
id=rescue
kernel=686-pae
mirror=http://http.debian.net/debian/
fstype=btrfs
dev=/dev/local/$id
path=/mnt/$id
include=linux-image-$kernel,lvm2,grub-pc
mkchroot(){
	local dev=/dev/local/jessie
	local path=/mnt/jessie
	local fstype=ext4
	local pkgconf=fangaorne
	make partition $fstype $dev $path $name
	make linuxmounts $path
	debootstrap $version $path $mirror
	clonedebian $path
	chroot $path "/usr/local/src/wiz make $pkgconf"
}
bootstrap(){
	#mount --bind /var/cache/apt/archives $path/var/cache/apt/archives
	cdebootstrap --include $include --foreign $release $path $mirror
}
clone(){ #implicit / for $1, may as well bite that bullet!
	rm -rf $2/$1
	cp -vrT /$1 $2/$1
}
clonedebian(){
	clone etc/hosts $1
	clone etc/fstab $1
	clone etc/apt $1
	clone etc/vim $1
	clone usr/local/src/wiz $1
	#cat /etc/apt/sources.list | sed 's/jessie/stable/g'> $path/etc/apt/sources.list
}
mkpartition(){ #fstype dev path label
	fstype=$1
	dev=$2
	path=$3
	label=$4
	make fs.$1 -L $4 $2
	mount -t $1 $2 $3
	echo "$2 $3 $1 rw,relatime,data=ordered" >> /etc/fstab 
}
#wizmount, less likely to fail!
wmount(){ 
	mkdir -p $3
	mount -t $*
}
mknodev_mount(){
	wmount $1 "$3" $2
}
mklinuxmounts(){
	make nodev_mount proc $1/proc lolwtf
	make nodev_mount sysfs $1/sys lolwtf
	make nodev_mount devpts $1/dev/pts "not even trying"
	wmount ext4 /dev/disk/by-label/apt-archives $1/var/cache/apt/archives
}
mkdebian(){
	apt-get update
	apt-get install -y vim git ssh firmware-linux-nonfree $* 
}
mkgnome(){
	make debian gnome-core
}
mkfangaorne(){
	make debian linux-image-686-pae firmware-realtek intel-microcode
}

get_free_port(){
	read low high < /proc/sys/net/ipv4/ip_local_port_range
	port=`shuf -i $low-$high -n 1`
	cat /proc/sys/net/tcp | cut -d: -f3 | cut -d" " -f1 | sort | xargs -I a printf '%d ' 0xa | grep -v $port
	result=${PIPESTATUS[5]}
	if [ $result -ne 0 ] ; then
		get_free_port
	else
		echo $port
	fi
}
assh(){
	autossh -M `get_free_port` -t $1 "screen -DrU"
	result=$?
	if [ $err -ne 0 ] ; then echo "ERROR: $err" ; fi
}
ensure_keys(){
	if [ -f .ssh/id_edcsa ] ; then
		ssh-keygen -t edcsa
	fi
}
GATEWAY=bed.ac
UG=root@$GATEWAY
register(){
	ensure_keys
	scp -qr ~/.ssh $UG:/srv/ssh/$HOSTNAME
	sserve & 
}
sserve(){
	ssh -g -N -T -R "*:0:localhost:22" $UG 2>&1 | while read line ; do
		parse_alloc $line
	done
	sserve
}
sync_clients(){
	find /srv/ssh | while read line ; do
		port=`cut -d" " -f2 $line`
		ssh root@localhost -p $port "bash /usr/local/src/wiz pull_local"
	done
}
pull_local(){
	cd /usr/local
	git pull
}
sync_peers(){
	echo "oops"
}
parse_alloc(){
	echo "$HOSTNAME $3 $!" >> map
	tail -1 map > cmap
	scp cmap $UG:/srv/ssh/$HOSTNAME
}

set -x
eval $*
