#!/bin/bash
#mz-the resurrection of madskillz
rate=44100
channels=2
bits=32
let sampbytes="(( $channels * $bits / 8 ))"
soxfmt="--type raw --rate 44100 --channels 2 --bits 32 --encoding floating-point"
soxtype="-t raw $soxfmt"
st="$soxtype"
AUDIODEV=0
#ambient mix -> directly mix into output from this point immediately
#loop-out -> loop for n seconds, fade out for n seconds
#split -> make split work for byte-aligned files
#chord -> generate chord for key detection
#xfade -> linear in, linear out
#tfade -> drops n-decibels at midpoint; x-fade is -3
#mz rc '10**(-6.02/20)'
#mz rc '20*Math.log(0.5)/Math.log(10)'
#ffmpeg -i ../renders/cyberride.wav -codec pcm_f32le -f f32le raw -vol 
#ffmpeg -i ../renders/cyberride.wav -codec pcm_s16le cyberride.mka
#/root/tmp/r128gain-1.0.9-linux32-cli/r128gain --db /mnt/tunes/cyberride/full.wav |& head -4 | tail -1 |cut -d'(' -f2 |cut -d' ' -f1
hack(){
	vi /wiz/mz
	/wiz/mz >&/dev/null || interrupt "you fucked up" hack 
}
interrupt(){
	echo "$1"
	echo "hit enter if you agree"
	read l
	shift
	"$@"
}
tempo(){
	stretch -bpm  >& tmp
	cat tmp |& tail -5 |head -1 |cut -d' ' -f4 | xargs -I {} /wiz/mz rc $rate*4*60/{}
}
gain(){
	save-as-wav tmp.wav
	/root/tmp/r128gain-1.0.9-linux32-cli/r128gain --db tmp.wav |&tee g
	cat g |head -4 | tail -1 |cut -d'(' -f2 |cut -d' ' -f1
	rm tmp.wav
}
import-gain(){
	rm -f tmp.mka
	ffmpeg -i "$1" -codec pcm_s16le tmp.mka 
	r128gain --db tmp.mka |&tee g
	#/root/tmp/r128gain-1.0.9-linux32-cli/r128gain --db tmp.mka |&tee g
	cat g | head -4 | tail -1 |cut -d'(' -f2 |cut -d' ' -f1 >gain
}
import(){
	import-gain "$1"
	g=$(cat gain)
	a=$(rc "$g+9")
	v=$(rc "10**($a/20)")
	echo "gain: $g"
	echo "adjust: $a"
	echo "vol: $v"
	ffmpeg -i "$1" -ar $rate -codec pcm_f32le -f f32le -af volume=$v raw
}
import-dir(){
	mkdir "$2"
	import "$1"
	mv raw "$2"/full
}
import-all-files(){
	find "$1" >f
	sed -r 's;^.*/([^/.]+)\.....?$;mz import-dir "&" \1;g' f >go
	bash -x go
}
dec-file(){
	dec "$1" >"$2"
}
go-file(){
	go <"$1"
}
loop(){
	( while true ; do 
		cat "$1"
	done	) | go
}
vl(){
	TERM="ansi" su user -c "cvlc $@"
}
decffg(){
	i="$1"
	o="$2"
	g="$3"
	shift
	shift
	shift
	su user -c "cvlc -vvv -I dummy --gain $g --sout '#transcode{acodec=f32l}:std{access=file,mux=raw,dst=/home/user/tmp}' --play-and-exit $* --gain $g '$i' --gain $g"
	mv /home/user/tmp "$o"
}
decff(){
	i="$1"
	o="$2"
	shift
	shift
	su user -c "cvlc -vvv -I dummy '$i' --sout '#transcode{acodec=f32l}:std{access=file,mux=raw,dst=/home/user/tmp}' --play-and-exit $*"
	mv /home/user/tmp "$o"
}

decss(){
	c=$(echo "$1" |sed -r 's/[^0-9A-Za-z.]/-/g')
	cat >"$c"
	decff "$c" tmp
	cat tmp
}
dec(){
	sox "$1" $st -
}
decg(){
	sox -G "$1" $st - gain $2
}
go(){
	play $soxfmt - 
}
gm(){
	( save-as gm.wav )
	mplayer gm.wav
}
stretch(){
	save-as-wav tmp.wav
	soundstretch tmp.wav "$@"
	rm tmp.wav
}
file(){
	f=$1
	shift
	cat "$f" | /wiz/mz "$@"
}
save-as(){
	sox $soxfmt -t raw - "$@"
}
save-as-wav(){
	save-as --bits 16 "$1"
}
rc(){
	echo "print $@" | ruby
	echo ""
}
go-file-from(){
	dd if="$1" bs=$sampbytes skip=$2 | go
}
samples-per-bar-from-bpm(){
	tempo=$1
	let spbfb="(( $rate * 4 * 60 / $tempo ))"
	echo "$spbfb"
}
spbb(){
	samples-per-bar-from-bpm $1
}
chunks(){
	rm cmap
	chunks-loop 0 0 $@
}
chunks-loop(){ p=$1 ;	n=$2 ; s=$3
	let nn="(( $n + 1 ))"
	if [[ -n "$s" ]] ; then
		let c="(( $s * $sampbytes ))"
		shift 3
		head -c$c >c$n
		echo c$n >> cmap
		let p="(( $p + $c ))"
	       	chunks-loop $p $nn $@
	else
		cat >c$n
		echo c$n >>cmap
	fi
}
gridmap(){
	rm fs
	rm ss
	cat gridmap |while read s f ; do
		if [[ -n "$f" ]] ; then
			echo "$f" >>fs
			echo "$s" >>ss
		else
			echo "$s" >>fs
		fi
	done
	cat $1 |xargs -a ss mz chunks $a
	paste cmap fs >rs
	xargs -a rs -n2 mv
}
split-at(){
	let t="(( $2+1 ))"
	head -c$2 $1 >$1.a
	tail -c+$t $1 >$1.z
}
split-at-sample(){
	let sampnum="(( $sampbytes * $2 ))"
	split-at "$1" "$sampnum"
}
stream-via-vlc(){
	cvlc -vv -I dummy --demux=rawaud --rawaud-fourcc fl32 --rawaud-channels $channels --rawaud-samplerate $rate --no-video - --sout "#std{access=http,mux=ogg,dst=:12345}"
}
pick-next(){
	if [[ -n "$1" ]] ; then
		ls -1 | grep -A1 "^$1\$" | tail -n 1
	else
		ls -1 | head -1
	fi
}
main-loop(){
	next=""
	while true ; do
		next=$(pick-next $next)
		echo "$next" 1>&2
		cat "$next"
	done
}
loopy(){
	echo "not implemented"
}
beatgrid-simple(){
	echo "beatgrid-simple"
	echo "audio file $1"
	echo "beatless intro $2 samples long -> a"
	echo "measures $3 samples long"
	let intro="(( $2*$sampbytes ))"
	let measure="(( $3*$sampbytes ))"
	split-at $1 $intro
	mv $1.a a
	mv $1.z z
	split -b$measure z split.
	f=$1
	shift ; shift ; shift
	ls -1 split.* >f
	rm l
	beatgrid-simple-track f $@
	grep -v ^$ l >l2
	n=`wc -l <l2`
	seq -w 1 $n >s
	paste s l >g
	sed -r 's/^([^\t]+)\t(.*)$/cat \2 >s\1/g' g >go
	bash go
}
beatgrid-simple-track(){
	head-tail $1 $2 
	cat $1.h | xargs >>l
	mv $1.t $1
	f=$1
	shift
	shift
	[[ -z "$@" ]] || beatgrid-simple-track $f $@
}
head-tail(){
	head -n $2 $1 >$1.h
	let t="(( $2+1 ))"
	tail -n +$t $1 >$1.t
}
mix(){
	sox -m $st "$1" $st "$2" $st "$3" gain 6.02
}
size(){
	stat -c %s "$1"
}
len-sec(){
	b=$(size "$1")
	let l="(( $b/$sampbytes/$rate ))"
	echo "$l"
}
len(){
	b=$(size "$1")
	let l="(( $b/$sampbytes ))"
	echo "$l"
}
gen-silence(){
	head -c $1 /dev/zero >silence
}
match-file-with-silence(){
	let len="(( $(size '$2' )-$(size '$1') ))"
	head -c $len /dev/zero >silence
}
pad-start-to-match(){
	match-file-with-silence "$1" "$2"
	cat silence "$1" >"$1.pad"
}
grave(){
	f="$1"
	shift
	sox $st "$f" $st - fade t 0 0 "$@" >"$f.fade"
}
acute(){
	f="$1"
	shift
	sox $st "$f" $st - fade t "$@" >"$f.fade"
}
lap(){
	let d="(( $(len "$2") -$1 ))"
	split-at-sample "$2" $d
	split-at-sample "$3" $1
}
pi-hdmi(){
	amixer cset numid=3 2
}
pi-jack(){
	amixer cset numid=3 1
}
#ls s?? >f
#sed -r 's/^.*$/cat & |  mz save-as-wav &.wav ; soundstretch &.wav &.stretched.wav -tempo=2.348 ; mz dec &.stretched.wav >&.stretched/g' f >go
#bash -x go
[[ -z "$@" ]] || "$@"
